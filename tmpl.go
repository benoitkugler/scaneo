package main

const (
	scansText = `{{define "scans"}}// DON'T EDIT *** generated by scaneo *** DON'T EDIT //

package {{.PackageName}}

import "database/sql"

{{range .Tokens}}func {{$.Visibility}}can{{title .Name}}(r *sql.Row) ({{.Name}}, error) {
	var s {{.Name}}
	if err := r.Scan({{range .Fields}}
		&s.{{.Name}},{{end}}
	); err != nil {
		return {{.Name}}{}, err
	}
	return s, nil
}

{{ if hasid .Fields }}
type {{.Name}}s map[int64]{{.Name}}

func (m {{.Name}}s) Ids() pq.Int64Array {
	out := make(pq.Int64Array, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}
{{ end }}

{{ if hasid .Fields }}
func {{$.Visibility}}can{{title .Name}}s(rs *sql.Rows) ({{.Name}}s, error) {
	structs := make({{.Name}}s,  16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{ else }}
func {{$.Visibility}}can{{title .Name}}s(rs *sql.Rows) ([]{{.Name}}, error) {
	structs := make([]{{.Name}}, 0, 16)
	var err error
	for rs.Next() {
		var s {{.Name}}
		if err = rs.Scan({{range .Fields}}
			&s.{{.Name}},{{end}}
		); err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}
{{ end }}

{{ if hasid .Fields }}
// Insert {{title .Name}} in the database and returns the item with id filled.
func (item {{title .Name}}) Insert(tx *sql.Tx) (out {{.Name}}, err error) {
	r := tx.QueryRow(` + "`" + `INSERT INTO {{snake .Name}}s (
		{{range $i, $e := noid .Fields}}{{if $i}},{{end}}{{snake $e.Name}}{{end}}
		) VALUES (
		{{range $i, $e := noid .Fields}}{{if $i}},{{end}}${{inc $i}}{{end}}
		) RETURNING 
		{{range $i, $e := .Fields}}{{if $i}},{{end}}{{snake $e.Name}}{{end}};
		` + "`" + `{{range noid .Fields}},item.{{.Name}}{{end}})
	return {{$.Visibility}}can{{title .Name}}(r)
}
{{ else }}
// Insert the links {{title .Name}} in the database.
func InsertMany{{title .Name}}s(tx *sql.Tx, items []{{title .Name}}) error {
	stmt, err := tx.Prepare(pq.CopyIn("{{snake .Name}}s", 
		{{range noid .Fields}}"{{snake .Name}}",{{end}}
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec({{range $i, $e := noid .Fields}}{{if $i}},{{end}}item.{{.Name}}{{end}})
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}
	
	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

{{ end }}

{{ if hasid .Fields }}
// Update {{title .Name}} in the database and returns the new version.
func (item {{title .Name}}) Update(tx *sql.Tx) (out {{.Name}}, err error) {
	r := tx.QueryRow(` + "`" + `UPDATE {{snake .Name}}s SET (
		{{range $i, $e := noid .Fields}}{{if $i}},{{end}}{{snake $e.Name}}{{end}}
		) = (
		{{range $i, $e := noid .Fields}}{{if $i}},{{end}}${{inc (inc $i)}}{{end}}
		) WHERE id = $1 RETURNING 
		{{range $i, $e := .Fields}}{{if $i}},{{end}}{{snake $e.Name}}{{end}};
		` + "`" + `{{range .Fields}},item.{{.Name}}{{end}})
	return {{$.Visibility}}can{{title .Name}}(r)
}
{{ end }}

{{ if hasid .Fields }}
// Delete {{title .Name}} in the database and the return the id.
// Only the field 'Id' is used.
func (item {{title .Name}}) Delete(tx *sql.Tx) (int64, error) {
	var deleted_id int64
	r := tx.QueryRow("DELETE FROM {{snake .Name}}s WHERE id = $1 RETURNING id;", item.Id)
	err := r.Scan(&deleted_id)
	return deleted_id, err
}
{{ else }}
// Delete the link {{title .Name}} in the database.
// Only the {{range foreign .Fields}}'{{.Name}}' {{end}}fields are used.
func (item {{title .Name}}) Delete(tx *sql.Tx) error {
	_, err := tx.Exec(` + "`" + `DELETE FROM {{snake .Name}}s WHERE 
	{{range $i, $e := foreign .Fields}}{{if $i}} AND {{end}}{{snake $e.Name }} = ${{inc $i}}{{end}};` +
		"`" + ` {{range foreign .Fields}},item.{{.Name}}{{end}})
	return err
}
{{ end }}

{{end}}
{{end}}`

	scansTextTest = `{{define "scansTest"}}// DON'T EDIT *** generated by scaneo *** DON'T EDIT //

package {{.PackageName}}

import (
	"database/sql"
	"math/rand"
)

{{range .Tokens}}
func rand{{title .Name}}() {{.Name}} {
	return {{.Name}}{ {{range .Fields}}
		{{.Name}}: {{rand .Type}},{{end}}
	}
}

func queries{{.Name}}(tx *sql.Tx, item {{.Name}}) ({{.Name}}, error) {
	{{ if hasid .Fields}} item, err := item.Insert(tx)
	{{ else }} err := InsertMany{{ .Name }}s(tx, []{{ .Name}}{item}) {{end}}
	if err != nil {
		return item, err
	}
	rows, err := tx.Query("SELECT * FROM {{snake .Name}}s")
	if err != nil {
		return item, err
	}
	items, err := {{$.Visibility}}can{{title .Name}}s(rows)
	if err != nil {
		return item, err
	}
	{{ if hasid .Fields }}
		_ = items.Ids()
	{{ else }}
		_ = len(items)
	{{ end }}



	{{ if hasid .Fields }}
	item, err = item.Update(tx)
	if err != nil {
		return item, err
	}
	row := tx.QueryRow("SELECT * FROM {{snake .Name}}s WHERE id = $1", item.Id)
	{{ else }} 
	row := tx.QueryRow(` + "`" + `SELECT * FROM {{snake .Name}}s WHERE 
		{{range $i, $e := foreign .Fields}}{{if $i}} AND {{end}}{{snake $e.Name }} = ${{inc $i}}{{end}};` + "`" +
		`{{range foreign .Fields}},item.{{.Name}}{{end}})
	{{ end }}

	_, err = {{$.Visibility}}can{{title .Name}}(row)
	return item, err
}

{{end}}
{{end}}`
)
